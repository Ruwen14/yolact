import numpy as np
from scipy.spatial.distance import cdist
import math
import cv2 as cv
import os.path
import logging
from tqdm import tqdm


def sliceNSortContours(cntrs, slice_stride:int, sort_mode:bool =False):
    """
    Args:
        cntrs: cntrs generated by calculations.getContours
        slice_stride: every N'th entry will remain
        sort_mode: bool, Whether to sort Contours from smallest to highest entry

    Returns: sliced or/and sorted contours
    """


    cnt_sliced = [cnt[1::math.ceil(len(cnt) / slice_stride)].reshape(-1, 2) for cnt in cntrs]


    if sort_mode == False:
       return cnt_sliced
    else:
        cnt_sorted = [cnt_s[np.argsort(cnt_s[:, 0])] for cnt_s in cnt_sliced]
        cnt_sorted.sort(key=lambda x: x[0][0])
        return cnt_sorted


def order_rect(pts):
    xSorted = pts[np.argsort(pts[:, 0]), :]

    # grab the left-most and right-most points from the sorted
    # x-roodinate points
    leftMost = xSorted[:2, :]
    rightMost = xSorted[2:, :]

    # now, sort the left-most coordinates according to their
    # y-coordinates so we can grab the top-left and bottom-left
    # points, respectively
    leftMost = leftMost[np.argsort(leftMost[:, 1]), :]
    (tl, bl) = leftMost

    # now that we have the top-left coordinate, use it as an
    # anchor to calculate the Euclidean distance between the
    # top-left and right-most points; by the Pythagorean
    # theorem, the point with the largest distance will be
    # our bottom-right point
    D = cdist(tl[np.newaxis], rightMost, "euclidean")[0]
    (br, tr) = rightMost[np.argsort(D)[::-1], :]

    # return the coordinates in top-left, top-right,
    # bottom-left, and bottom-right order
    return np.array([tl, tr, bl, br])





class VideoMultiView(object):

    def __init__(self, video_paths: list, target_fps=None, target_resolution=None):

        assert type(video_paths) == list, 'Video Paths have to be lists'

        if target_resolution is not None:
            assert type(target_resolution) == tuple, 'Wrong format of target_resolution Format --> (width, height)'

        for path in video_paths:
            assert os.path.isfile(path), f'{path} dont exist'

        self.VideoObjs = [cv.VideoCapture(path) for path in video_paths]
        self.target_fps = target_fps if target_fps is not None else self.VideoObjs[0].get(cv.CAP_PROP_FPS)
        self.frame_count = int(max([obj.get(cv.CAP_PROP_FRAME_COUNT) for obj in self.VideoObjs]))
        self.target_resolution = target_resolution

    def view(self, sep_line=True, resize=True):

        pbar = tqdm(total=self.frame_count, desc='Video Progress')

        while (True):

            sucess, frames = self._grab_frames()

            if resize:
                frames = [cv.resize(frame, (800, 450)) for frame in frames]

            if all(sucess):
                stacked_frames = self._hstack(frames, sep_line)

                if self.target_resolution is not None:
                    stacked_frames = cv.resize(stacked_frames, self.target_resolution)

                cv.imshow("MultiView", stacked_frames)

                if cv.waitKey(int(1000 / self.target_fps)) & 0xFF == ord('q'):
                    break

                pbar.update(1)

            else:
                break

        pbar.close()
        [video.release() for video in self.VideoObjs]
        cv.destroyAllWindows()

    def save(self, path):
        vid1 = cv.VideoCapture('merge1.mp4')
        fourcc = cv.VideoWriter_fourcc(*'XVID')
        if os.path.isfile(path):
            logging.warning(f"  Overwriting existings file {path}")
        # if self.target_resolution is not None:
        #     Writer = cv.VideoWriter(path, cv.VideoWriter_fourcc(*"mp4v"), self.target_fps, self.target_resolution)
        # else:
        frame_size = ((vid1.get(cv.CAP_PROP_FRAME_WIDTH), vid1.get(cv.CAP_PROP_FRAME_HEIGHT)))
        frame_size = (int(frame_size[0]), int(frame_size[1]))
        fps = vid1.get(cv.CAP_PROP_FPS)
        fpa = self.target_fps
        Writer = cv.VideoWriter(path, fourcc, fps, (frame_size))

        pbar = tqdm(total=self.frame_count, desc='Save Progress')
        while (True):

            # sucess, frames = self._grab_frames()
            sucess, frame = vid1.read()
            cv.imshow("", frame)

            if sucess:
                Writer.write(frame)

                if cv.waitKey(1) & 0xFF == ord('q'):
                    break

            # if all(sucess):
            #     stacked_frames = self._hstack(frames, draw_sep=True)
            #
            #     if self.target_resolution is not None:
            #         stacked_frames = cv.resize(stacked_frames, self.target_resolution)
            #
            #     Writer.write(stacked_frames)
            #     if cv.waitKey(1) & 0xFF == ord('q'):
            #         break

            # if cv.waitKey(int(1000 / self.target_fps)) & 0xFF == ord('q'):
            #     break

            #     pbar.update(1)
            #
            # else:
            #     break
        # pbar.close()
        # [video.release() for video in self.VideoObjs]
        vid1.release()
        Writer.release()
        cv.destroyAllWindows()

    def _hstack(self, frames, draw_sep):
        h_stacked = cv.hconcat(frames)
        if draw_sep:
            height, width, _ = h_stacked.shape
            cv.line(h_stacked, (int(width / 2), 0), (int(width / 2), height), (255, 255, 255), 1)
        return h_stacked

    def _grab_frames(self):
        return zip(*[video.read() for video in self.VideoObjs])

    # if __name__ == '__main__':
    #     MultiVideo = VideoMultiView(video_paths=['video3.mp4', 'output_2.mp4'])
    #
    #     MultiVideo.view()
